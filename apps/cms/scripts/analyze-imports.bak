import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'node:url';
import { glob } from 'glob';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Extract package name from an import statement
 */
function extractPackageName(importStatement: string): string | null {
  // Remove quotes and match package patterns
  const clean = importStatement.trim().replace(/['"]/g, '');

  // Skip relative imports and absolute paths
  if (clean.startsWith('.') || clean.startsWith('/') || clean.includes(':')) {
    return null;
  }

  // Handle scoped packages (@scope/package) and regular packages
  const parts = clean.split('/');
  let packageName = parts[0];

  // Handle scoped packages (@scope/package)
  if (packageName.startsWith('@')) {
    if (parts.length > 1) {
      packageName = `${parts[0]}/${parts[1]}`;
    }
  } else {
    // For non-scoped packages, take only the first part
    packageName = parts[0];
  }

  // Filter out Node.js built-ins and special modules
  if (
    packageName.startsWith('node:') ||
    !packageName ||
    packageName === 'next' ||
    (packageName.startsWith('@') && packageName.split('/').length !== 2)
  ) {
    return null;
  }

  return packageName;
}

/**
 * Extract all imports from a file
 */
function extractImports(filePath: string): Set<string> {
  const imports = new Set<string>();

  try {
    const content = fs.readFileSync(filePath, 'utf-8');

    // Match various import patterns
    const importPatterns = [
      /import\s+.*?\s+from\s+['"]([^'"]+)['"]/g, // import ... from 'module'
      /import\s+['"]([^'"]+)['"]/g, // import 'module'
      /require\s*\(\s*['"]([^'"]+)['"]\s*\)/g, // require('module')
      /from\s+['"]([^'"]+)['"]/g, // from 'module'
      /import\(['"]([^'"]+)['"]\)/g // dynamic import()
    ];

    for (const pattern of importPatterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        const moduleName = match[1];
        if (moduleName) {
          const packageName = extractPackageName(moduleName);
          if (packageName) {
            imports.add(packageName);
          }
        }
      }
    }
  } catch (error) {
    console.warn(`Error reading file ${filePath}:`, error);
  }

  return imports;
}

/**
 * Recursively get all dependencies by reading package.json files
 */
function getDependencyTree(
  packageName: string,
  nodeModulesPath: string,
  visited: Set<string> = new Set()
): Set<string> {
  const dependencies = new Set<string>();
  if (visited.has(packageName)) {
    return dependencies;
  }
  visited.add(packageName);

  const packagePath = path.join(nodeModulesPath, packageName);
  const packageJsonPath = path.join(packagePath, 'package.json');

  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
      const deps = {
        ...(packageJson.dependencies || {}),
        ...(packageJson.peerDependencies || {})
      };

      for (const [depName] of Object.entries(deps)) {
        dependencies.add(depName);
        // Recursively get dependencies of dependencies (limited depth)
        if (visited.size < 100) {
          const subDeps = getDependencyTree(depName, nodeModulesPath, visited);
          subDeps.forEach((dep) => dependencies.add(dep));
        }
      }
    } catch (error) {
      console.warn(`Error reading package.json for ${packageName}:`, error);
    }
  }

  return dependencies;
}

/**
 * Find all symlinks in node_modules and resolve them
 */
function findAndResolveSymlinks(nodeModulesPath: string): {
  symlinks: string[];
  resolvedSymlinks: Record<string, string>;
} {
  const symlinks: string[] = [];
  const resolvedSymlinks: Record<string, string> = {};

  if (!fs.existsSync(nodeModulesPath)) {
    return { symlinks, resolvedSymlinks };
  }

  try {
    const entries = fs.readdirSync(nodeModulesPath, { withFileTypes: true });

    for (const entry of entries) {
      const entryPath = path.join(nodeModulesPath, entry.name);

      try {
        const stats = fs.lstatSync(entryPath);
        if (stats.isSymbolicLink()) {
          symlinks.push(entry.name);

          // Resolve the symlink to get the actual path
          const resolvedPath = fs.realpathSync(entryPath);

          // Extract the package name from the resolved path if it's in node_modules
          const resolvedParts = resolvedPath.split(path.sep);
          const resolvedNodeModulesIndex = resolvedParts.indexOf('node_modules');

          if (resolvedNodeModulesIndex !== -1 && resolvedNodeModulesIndex < resolvedParts.length - 1) {
            // Get the package name from resolved path
            let resolvedPackageName = resolvedParts[resolvedNodeModulesIndex + 1];

            // Handle scoped packages
            if (resolvedPackageName?.startsWith('@') && resolvedNodeModulesIndex + 2 < resolvedParts.length) {
              resolvedPackageName = `${resolvedPackageName}/${resolvedParts[resolvedNodeModulesIndex + 2]}`;
            }

            // Store the mapping: symlink package name -> resolved package name
            resolvedSymlinks[entry.name] = resolvedPackageName;

            console.log(`Found symlink: ${entry.name} -> ${resolvedPackageName} (${resolvedPath})`);
          } else {
            // Symlink points outside node_modules, store the full resolved path
            resolvedSymlinks[entry.name] = resolvedPath;
            console.log(`Found external symlink: ${entry.name} -> ${resolvedPath}`);
          }
        }
      } catch (_error) {
        // Skip entries that can't be accessed
        continue;
      }
    }
  } catch (error) {
    console.warn('Error scanning node_modules:', error);
  }

  return { symlinks, resolvedSymlinks };
}

/**
 * Main function to analyze imports and generate whitelist
 */
async function analyzeImports(): Promise<void> {
  const projectRoot = path.join(__dirname, '..');
  const srcPath = path.join(projectRoot, 'src');
  const nodeModulesPath = path.join(projectRoot, 'node_modules');
  const outputPath = path.join(projectRoot, '.next', 'allowed-modules.json');

  console.log('Analyzing imports from source files...');

  // Find all TypeScript/JavaScript files
  const files = [
    // Source files
    ...(await glob('**/*.{ts,tsx,js,jsx}', {
      cwd: srcPath,
      absolute: true,
      ignore: ['**/*.d.ts', '**/node_modules/**']
    })),
    // Root config files
    ...(await glob('*.{ts,tsx,js,jsx}', {
      cwd: projectRoot,
      absolute: true,
      ignore: ['**/node_modules/**']
    })),
    // Next.js config files
    ...(await glob('**/next.config.{ts,js}', {
      cwd: projectRoot,
      absolute: true,
      ignore: ['**/node_modules/**']
    })),
    // Plugin files
    ...(await glob('plugins/**/*.{ts,js}', {
      cwd: projectRoot,
      absolute: true,
      ignore: ['**/node_modules/**']
    }))
  ];

  const allImports = new Set<string>();

  // Extract imports from all files
  for (const file of files) {
    const imports = extractImports(file);
    imports.forEach((imp) => allImports.add(imp));
  }

  console.log(`Found ${allImports.size} direct imports`);

  // Get all transitive dependencies
  const allDependencies = new Set<string>(allImports);

  for (const packageName of allImports) {
    if (fs.existsSync(path.join(nodeModulesPath, packageName))) {
      const deps = getDependencyTree(packageName, nodeModulesPath);
      deps.forEach((dep) => allDependencies.add(dep));
    }
  }

  // Also include Next.js and React core packages (always needed)
  allDependencies.add('next');
  allDependencies.add('react');
  allDependencies.add('react-dom');
  allDependencies.add('react/jsx-runtime');

  // Find and resolve symlinks
  console.log('Scanning for symlinks in node_modules...');
  const { symlinks, resolvedSymlinks } = findAndResolveSymlinks(nodeModulesPath);

  // Create output directory if it doesn't exist
  const outputDir = path.dirname(outputPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Save results
  const result = {
    allowedModules: Array.from(allDependencies).sort(),
    symlinks,
    resolvedSymlinks,
    generatedAt: new Date().toISOString(),
    totalFiles: files.length
  };

  fs.writeFileSync(outputPath, JSON.stringify(result, null, 2));

  console.log('\nAnalysis complete:');
  console.log(`- Total source files analyzed: ${files.length}`);
  console.log(`- Unique packages found: ${allDependencies.size}`);
  console.log(`- Symlinks found: ${symlinks.length}`);
  if (symlinks.length > 0) {
    console.log(`- Symlinked packages: ${symlinks.join(', ')}`);
  }
  console.log(`- Results saved to: ${outputPath}`);
}

// Run the analysis
analyzeImports().catch((error) => {
  console.error('Error analyzing imports:', error);
  process.exit(1);
});
